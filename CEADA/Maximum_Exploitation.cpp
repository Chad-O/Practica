// time-limit: 2000
// problem-url: https://csacademy.com/ieeextreme15/task/exploitation/
#include <bits/stdc++.h>
using namespace std;
#define MP make_pair
#define umap unordered_map
#define uset unordered_set
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int MOD = 1000000007;
#ifndef ONLINE_JUDGE
#define deb(x) cout << #x << '=' << x << '\n'
#else
#define deb(x)
#endif

int calcSum(pii up, pii bottom, vector<vi>& query) {
	return query[bottom.first+1][bottom.second+1]+query[up.first][up.second] -
			query[up.first][bottom.second+1] - query[bottom.first+1][up.second];
}

bool isOverlap(pii up1, pii bottom1, pii up2, pii bottom2) {
    if(up1.first == bottom1.first || up1.second == bottom1.second || up2.first == bottom2.first || up2.second == bottom2.second)
	{
		return false;
	}
	if(up1.first >= bottom2.first || up2.first >= bottom1.first)
	{
		return false;
	}
	if(bottom1.second >=up2.second || bottom2.second >= up1.second)
	{
		return false;
	}
	return true;
}

int R, C;
int X, Y;
void solve() {
	cin >> R >> C >> X >> Y;
	vector<vi> mat(R, vi(C));
	vector<vi> query(R+1, vi(C+1));
	for (int i = 0; i < R; ++i) {
		for (int j = 0; j < C; ++j) {
			cin >> mat[i][j];
		}
	}
	for (int i = 0; i <= R; ++i) {
		for (int j = 0; j <= C; ++j) {
			if (i == 0 || j == 0) {
				query[i][j] = 0;
			} else {
				query[i][j] = mat[i-1][j-1]+query[i-1][j]+query[i][j-1]-query[i-1][j-1];
			}
		}
	}

	// sum, UP(x, y) bottom (x, y)
	vector<vi> sums;
	for (int i = 0; i < R; ++i) {
		for (int j = 0; j < C; ++j) {
			if (i+X < R && j+Y < C) {
				int calc = calcSum({i, j}, {i+X-1, j+Y-1}, query);
				sums.push_back({calc, i+X, j, i, j+Y});
			}
			if (i+Y < R && j+X < C) {
				int calc = calcSum({i, j}, {i+X-1, j+Y-1}, query);
				sums.push_back({calc, i+X, j, i, j+Y});
			}
		}
	}
	sort(sums.begin(), sums.end());

	int best = INT_MIN;
	for (int i = 0; i < sums.size()-1; ++i) {
		for (int j = i+1; j < sums.size(); ++j) {
			pii up1 = {sums[i][1], sums[i][2]};
			pii bottom1 = {sums[i][3], sums[i][4]};
			pii up2 = {sums[j][1], sums[j][2]};
			pii bottom2 = {sums[j][3], sums[j][4]};
			if (!isOverlap(up1, bottom1, up2, bottom2)) {
				best = max(best, sums[i][0]+sums[j][0]);
			}
		}
	}
	cout << best << '\n';

}

int main(int argc, const char** argv) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
	solve();
    return 0;
}
